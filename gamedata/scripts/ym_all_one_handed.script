--#region debug


local function dbg_print(msg, ...)
    if not ym_debug then return end
    

    ym_debug.set_modname("all one handed")
    ym_debug.dbg_print(msg,...)
end

local function dbg_dump(o)
    if not ym_debug then return end

    return ym_debug.dbg_dump(o)
end

local function newline()
    if not ym_debug then return end
    ym_debug.dbg_newline()
end
--#endregion

if not grok_bo_enhanced_recoil or not grok_bo_enhanced_recoil.modifier then
    printf("!Enhanced Recoil Gold is not installed. Stopping Mod")
    return
end

local idp            = round_idp
local org_get_recoil = grok_bo_enhanced_recoil.get_weapon_recoil_gold
local add_modifier = grok_bo_enhanced_recoil.add_modifier
local remove_modifier = grok_bo_enhanced_recoil.remove_modifier
local modifier = grok_bo_enhanced_recoil.modifier
    --#endregion

device_sec_blacklist = {}
device_sec_whitelist = {}
device_kind_blacklist = {}
device_kind_whitelist = {}

wpn_sec_blacklist = {}
wpn_sec_whitelist = {}
wpn_kind_blacklist = {}
wpn_kind_whitelist = {}

--[[ 
    mod_func is a simple function to add to Enhanced Recoil Gold, modding the recoil of ALL weapons, doesn't 
    matter which is out
--]]
local mod_func        = function(effect_power, wpn, wpn_fx)
    dbg_print("mod func running")
    return effect_power * 7
end

local wpn_out = 4 
local IsModded = false

local function save_state(mdata) 
    mdata.detector_out = detector_out
end

local function load_state(mdata) 
    detector_out = mdata.detector_out or false
end

local function load_settings()
    newline()
    dbg_print("load_settings")
    device_kind_whitelist = {}
    device_kind_blacklist = {}
    device_sec_blacklist = {}
    device_sec_whitelist = {}

    wpn_kind_whitelist = {}
    wpn_kind_blacklist = {}
    wpn_sec_blacklist = {}
    wpn_sec_whitelist = {}


	-- local detector = db.actor:active_detector()
    -- local section = detector:section()
    -- local kind = ini_sys:r_string_ex(section,"kind") or "unknown"
	-- local wep = db.actor:active_item()

    -- detector_out = kind == "i_device" and not wep and db.actor:active_detector()
    detector_out = db.actor:active_detector() or false
    dbg_print("detector_out = %s", detector_out)


    --#region Device lists
    -- Section 
    local n = ini:line_count("device_sec_blacklist")
    for i = 0, n-1 do
        local result, sec = ini:r_line_ex("device_sec_blacklist")
        if sec then
            device_sec_blacklist[sec] = true
        end
    end

    n = ini:line_count("device_sec_whitelist")
    for i = 0, n-1 do
        local result, sec = ini:r_line_ex("device_sec_whitelist")
        if sec then
            device_sec_whitelist[sec] = true
        end
    end

    -- Kind
    n = ini:line_count("device_kind_blacklist")
    for i = 0, n-1 do
        local result, kind = ini:r_line_ex("device_kind_blacklist")
        dbg_print("device_kind = %s", kind)
        if kind then
            device_kind_blacklist[kind] = true
        end
    end

    n = ini:line_count("device_kind_whitelist")
    for i = 0, n-1 do
        local result, kind = ini:r_line_ex("device_kind_whitelist")
        if kind then
            device_kind_whitelist[kind] = true
        end
    end
    --#endregion

    --#region Weapon lists
    -- Section 
    local n = ini:line_count("wpn_sec_blacklist")
    for i = 0, n-1 do
        local result, sec, i = ini:r_line_ex("wpn_sec_blacklist",i, "", "")
        if sec then
            i = i or 3
            wpn_sec_blacklist[sec] = i 
        end
    end

    n = ini:line_count("wpn_sec_whitelist")
    for i = 0, n-1 do
        local result, sec = ini:r_line_ex("wpn_sec_whitelist")
        if sec then
            wpn_sec_whitelist[sec] = true
        end
    end

    -- Kind
    n = ini:line_count("wpn_kind_blacklist")
    for i = 0, n-1 do
        local result, kind, i = ini:r_line_ex("wpn_kind_blacklist",i, "", "")
        dbg_print("wpn_kind = %s", kind)
        if kind then
            i = i or 3 -- default to allow hipfire and ADS but with recoil debuff
            wpn_kind_blacklist[kind] = i 
        end
    end

    n = ini:line_count("wpn_kind_whitelist")
    for i = 0, n-1 do
        local result, kind = ini:r_line_ex("wpn_kind_whitelist")
        if kind then
            wpn_kind_whitelist[kind] = true
        end
    end
    


    --#endregion
end



local function actor_on_first_update()
    load_settings()
    -- dbg_print("key_bindings = %s", dbg_dump(key_bindings))
end

--#region mod recoil
-- local function actor_on_weapon_before_fire(flags)
--     dbg_print("actor_on_weapon_before_fire")

-- 	if not db.actor then return end

-- 	local wpn   = db.actor:active_item()
-- 	if not wpn then return end

-- 	if game.actor_weapon_lowered() == true then return end

--     local sec_p = ini_sys:r_string_ex(wpn:section(), "parent_section") or wpn:section()


        (IsBolt(nil, wpn_cls)) or
        (wpn_out ~= 2) or     -- 2 and 3 are the only blacklist options with recoil debuffs
        (wpn_out ~= 3)
     then 
        remove_modifier(mod_func)

--     local detector_out =  db.actor:active_detector() and true or false
--     dbg_print("active_detector = %s", detector_out)


--     if detector_out then 
--         -- if not modded_wpns[sec_p] then
--         if not IsModded then
--             add_modifier(mod_func)
--             IsModded = true 
--             -- modded_wpns[sec_p] = true
--         end
--     else
--         remove_modifier(mod_func)
--         IsModded = false
--         -- modded_wpns[sec_p] = nil
--     end



-- end

--#endregion


-- TODO: disable hipfire but allow aiming with device
-- TODO: mcm for many options

function on_detector_start(anm_table, item)
	if not item then return end

    newline()
    dbg_print("on_detector_start")

    device_kind_blacklist = device_kind_blacklist
    device_kind_whitelist = device_kind_whitelist
    device_sec_blacklist = device_sec_blacklist
    device_sec_whitelist = device_sec_whitelist

    wpn_kind_blacklist = wpn_kind_blacklist
    wpn_kind_whitelist = wpn_kind_whitelist
    wpn_sec_blacklist = wpn_sec_blacklist
    wpn_sec_whitelist = wpn_sec_whitelist


    local section = item:section() -- section here is the weapon/detector
    local kind = ini_sys:r_string_ex(section,"kind") or "unknown"
    local anm_name = anm_table.anm_name

    newline()
    dbg_print("actor_on_hud_animation_play")

    -- dbg_print("anm_name = %s", anm_name)

    -- Grab equipped weapon
    local obj = db.actor:active_item()
    local wpn = nil
    local wpn_kind = nil
    local wpn_sec = nil
    if (obj) then
        wpn = obj
        wpn_sec = wpn:section()
        wpn_kind = ini_sys:r_string_ex(obj:section(),"kind") or "unknown" -- "kind" is usually "i_device"
    end

    dbg_print("wpn = %s", wpn)
    dbg_print("wpn_kind = %s", wpn_kind)


    -- Weapon checks
    if wpn_kind and wpn_kind_blacklist[wpn_kind] then
        -- Section blacklist takes priority over kind blacklist
        if wpn_sec_blacklist[wpn_sec] then
            wpn_out = wpn_sec_blacklist[wpn_sec]
        else
            wpn_out = wpn_kind_blacklist[wpn_kind]
        end
    end

    -- Whitelists take priority
    -- if there are duplicates on the blacklist and whitelist, the whitelist wins out
    if wpn_kind and (wpn_kind_whitelist[wpn_kind] or wpn_sec_whitelist[wpn_sec]) then
        wpn_out = 4
    end


    ::device::




    -- Device checks
    -- Check if current hud item is in the blacklists (i.e. the detectors are playing animations)
    if device_kind_blacklist[kind] or device_sec_blacklist[section] then
            detector_out = true
    end

    -- Whitelists take priority
    -- if there are duplicates on the blacklist and whitelist, the whitelist wins out
    if device_kind_whitelist[kind] or device_sec_whitelist[section] then
        detector_out = false
    end

    ::continue::

    dbg_print("ALLOW_HIPFIRE = %s, about_to_zoom = %s",ALLOW_HIPFIRE, is_zoomed)
    -- if not ALLOW_HIPFIRE and not is_zoomed then game.actor_lower_weapon(detector_out) end
    if ((not ALLOW_HIPFIRE) and (not is_zoomed) and detector_out and (wpn_out < 3)) then
        game.actor_lower_weapon(true)
    end
    dbg_print("detector_out = %s", detector_out)
    dbg_print("wpn_out = %s", wpn_out)
end



local function actor_on_weapon_raise(wpn)
    if not wpn then return end
    newline()
    dbg_print("actor_on_weapon_raise, wpn = %s", wpn)
    if detector_out then return end
end

local function actor_on_weapon_lower(wpn)
    if not wpn then return end
    newline()
    dbg_print("actor_on_weapon_lower, wpn = %s", wpn)
end

local function on_before_key_press(key, bind, dis, flags)
    -- dbg_print("flags = %s", dbg_dump(flags))
    -- dbg_print("kWPN_FIRE = %s, kWPN_ZOOM = %s", key_bindings.kWPN_FIRE, key_bindings.kWPN_ZOOM)


    -- dbg_print("bind == kWPN_FIRE = %s, bind == kWPN_ZOOM = %s", bind == key_bindings.kWPN_FIRE, bind == key_bindings.kWPN_ZOOM) 
    if ((bind == key_bindings.kWPN_FIRE) or (bind == key_bindings.kWPN_ZOOM)) then
        newline()
        dbg_print("on_before_key_press")
        dbg_print("detector_out = %s", detector_out)

        if detector_out then flags.ret_value = false end
    end
    
end

local function on_key_press(key)
    newline()
    dbg_print("on_key_press")
	local bind = dik_to_bind(key)

    dbg_print("key = %s", key)
    dbg_print("bind = %s", bind)
    -- TODO: add hide quick detector on combat and weapon is out
    -- if uni_anim_detectors and bind == key_bindings.kNIGHT_VISION and db.actor:active_detector() then
    --     uni_anim_detectors.force_quick = true
    --     return
    -- end
    
    -- if (bind == key_bindings.)


--     dbg_print("key_bindings[key] = %s", key_bindings[key])
--     if not detector_out then goto continue end

--     if ((bind == 30) or (bind == 31))
--     -- if (bind == key_bindings.kWPN_FIRE)
--     then
--         dbg_print("stopping fire or zoom")
--         return
--     end

--     ::continue::
end

-- local function on_key_release(key)
--     -- newline()
--     -- dbg_print("on_key_release")

-- 	-- local bind = dik_to_bind(key)
--     -- dbg_print("bind = %s", bind)
--     -- if not detector_out then goto continue end

--     -- if ((bind == 51) or (bind == 46))
--     -- then
--     --     dbg_print("stopping fire or zoom")
--     --     return
--     -- end

--     -- ::continue::
-- end


-- local function on_key_hold(key)
--     -- newline()
--     -- dbg_print("on_key_hold")

-- 	-- local bind = dik_to_bind(key)
--     -- dbg_print("bind = %s", bind)
--     -- if not detector_out then goto continue end

--     -- if ((bind == 51) or (bind == 46))
--     -- then
--     --     dbg_print("stopping fire or zoom")
--     --     return
--     -- end

--     -- ::continue::
-- end

-- local function actor_on_weapon_zoom_in()
--     if detector_out then return end
    
-- end


-- local function actor_on_weapon_before_fire(flags)
--     dbg_print("actor_on_weapon_before_fire")
--    if detector_out then return end 
-- end

local function actor_item_to_slot(obj)
    dbg_print("actor_item_to_slot")
	detector_out = db.actor:active_detector()
    game.actor_lower_weapon(detector_out)
end

local function on_option_change()
    load_settings()
    
    wpn_out = 4
end


function on_game_start()
    RegisterScriptCallback("save_state",save_state)
    RegisterScriptCallback("load_state",load_state)
    RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
    -- RegisterScriptCallback("actor_on_hud_animation_end", on_detector_end)
	-- RegisterScriptCallback("actor_on_weapon_before_fire", actor_on_weapon_before_fire)
	RegisterScriptCallback("actor_on_weapon_raise",actor_on_weapon_raise)
	RegisterScriptCallback("actor_on_weapon_lower",actor_on_weapon_lower)
    RegisterScriptCallback("actor_on_hud_animation_play", on_detector_start)
    RegisterScriptCallback("on_key_press", on_key_press)
    -- RegisterScriptCallback("on_key_release", on_key_release)
    -- RegisterScriptCallback("on_key_hold", on_key_hold)
    -- RegisterScriptCallback("actor_on_weapon_zoom_in", actor_on_weapon_zoom_in)
    RegisterScriptCallback("on_before_key_press", on_before_key_press)
    RegisterScriptCallback("actor_item_to_slot", actor_item_to_slot)
    RegisterScriptCallback("on_option_change", on_option_change)
end
